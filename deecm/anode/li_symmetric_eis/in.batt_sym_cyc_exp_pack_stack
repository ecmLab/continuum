# Battery simulation using pre-compacted particles from restart file
# With type-based boundary conditions for SOR solver
# To Do need to create a SOR that does current from CC to LI Instead
# SE particles (type 1) - Solid Electrolyte
# CCC particles (type 2) - Lithium Layer 1 (Bottom)
# ACC particles (type 3) - Lithium Layer 2 (top)
# Wall particles (type 4) - Walls

# --- 1. INITIALIZATION ---
units           micro  # Using micro units to match the compaction script
atom_style      granular
atom_modify     map array
boundary        f f f  # Fixed boundaries as in compaction script
newton          off

communicate     single vel yes

# Set timestep (Do not change radius update optimized for this value)
timestep        5.e-6

# --- 2. READ RESTART FILE ---
# Read the compacted configuration
read_data     data/comp200_sym_pack.data

# --- 3. RE-ESTABLISH GROUPS ---
# Define groups based on particle types (Type 6 is the wall)
group  acc   type  5   # Current Collector (top)
group  ali   type  3   # Lithium 2 (top)
group  se    type  1   # Solid Electrolyte
group  cli   type  2   # Lithium 1 (bottom)
group  ccc   type  4   # Current Collector (bottom)

group  ptc   type  1 2 3 # Types effected by walls
group  li    type  2 3 # Lithium type

# --- 4. NEIGHBOR SETTINGS ---
neighbor        0.001 bin
neigh_modify    every 1 delay 0 check yes

# --- 5. RE-ESTABLISH MATERIAL PROPERTIES ---
# Young's modulus (from compaction script)
variable        Yse           equal     23.e6  # SE (Solid Electrolyte) [kPa] (From Paper LPS)
variable        Yli           equal     10.e6  # Li (Lithium Metal) [kPa] (From Paper LPS)
variable        Ycc           equal     120.e6  # Li (Lithium Metal) [kPa] (https://www.azom.com/properties.aspx?ArticleID=597)
variable        Yww           equal     50.e6    # Wall [kPa]

variable        particle_poissons_ratio equal 0.4

# Material properties
fix     m1 all property/global youngsModulus peratomtype ${Yse} ${Yli} ${Yli} ${Ycc} ${Ycc} ${Yww}
fix     m2 all property/global poissonsRatio peratomtype ${particle_poissons_ratio} ${particle_poissons_ratio} ${particle_poissons_ratio} ${particle_poissons_ratio} ${particle_poissons_ratio} ${particle_poissons_ratio}

# Coefficient of restitution matrix (4x4)
variable        cor_all       equal     0.1     # Same for all pairs
fix     m3 all property/global coefficientRestitution peratomtypepair 6 &
        ${cor_all} ${cor_all} ${cor_all} ${cor_all} ${cor_all} ${cor_all} &
        ${cor_all} ${cor_all} ${cor_all} ${cor_all} ${cor_all} ${cor_all} &
        ${cor_all} ${cor_all} ${cor_all} ${cor_all} ${cor_all} ${cor_all} &
        ${cor_all} ${cor_all} ${cor_all} ${cor_all} ${cor_all} ${cor_all} &
        ${cor_all} ${cor_all} ${cor_all} ${cor_all} ${cor_all} ${cor_all} &
        ${cor_all} ${cor_all} ${cor_all} ${cor_all} ${cor_all} ${cor_all}

# Coefficient of friction (all 0.1 from compaction)
variable        cof_all       equal     0.1     # Same for all pairs
fix     m4 all property/global coefficientFriction peratomtypepair 6 &
        ${cof_all} ${cof_all} ${cof_all} ${cof_all} ${cof_all} ${cof_all} &
        ${cof_all} ${cof_all} ${cof_all} ${cof_all} ${cof_all} ${cof_all} &
        ${cof_all} ${cof_all} ${cof_all} ${cof_all} ${cof_all} ${cof_all} &
        ${cof_all} ${cof_all} ${cof_all} ${cof_all} ${cof_all} ${cof_all} &
        ${cof_all} ${cof_all} ${cof_all} ${cof_all} ${cof_all} ${cof_all} &
        ${cof_all} ${cof_all} ${cof_all} ${cof_all} ${cof_all} ${cof_all} 

# Coefficient of rolling friction (all 0.1 from compaction)
variable        corf_all      equal     0.1     # Same for all pairs
fix     m5 all property/global coefficientRollingFriction peratomtypepair 6 &
        ${corf_all} ${corf_all} ${corf_all} ${corf_all} ${corf_all} ${corf_all} &
        ${corf_all} ${corf_all} ${corf_all} ${corf_all} ${corf_all} ${corf_all} &
        ${corf_all} ${corf_all} ${corf_all} ${corf_all} ${corf_all} ${corf_all} &
        ${corf_all} ${corf_all} ${corf_all} ${corf_all} ${corf_all} ${corf_all} &
        ${corf_all} ${corf_all} ${corf_all} ${corf_all} ${corf_all} ${corf_all} &
        ${corf_all} ${corf_all} ${corf_all} ${corf_all} ${corf_all} ${corf_all} 

# Cohesion energy density (from compaction script)
fix     m6 all property/global cohesionEnergyDensity peratomtypepair 6 &
        50000  70000  70000  10000 10000 0 &
        70000  70000  70000  10000 10000 0 &
        70000  70000  70000  10000 10000 0 &
        10000  10000  10000  0     0     0 &
        10000  10000  10000  0     0     0 &
        0       0       0    0     0     0 

# --- 6. PAIR STYLE AND WALLS ---
pair_style gran model hertz tangential history cohesion sjkr
pair_coeff * *

# Re-establish wall boundaries (from compaction script)
fix xwalls1 ptc wall/gran model hertz tangential history primitive type 6 xplane -10
fix xwalls2 ptc wall/gran model hertz tangential history primitive type 6 xplane 10
fix ywalls1 ptc wall/gran model hertz tangential history primitive type 6 yplane -10
fix ywalls2 ptc wall/gran model hertz tangential history primitive type 6 yplane 10
fix zwalls1 ptc wall/gran model hertz tangential history primitive type 6 zplane 0
fix zwalls2 ptc wall/gran model hertz tangential history primitive type 6 zplane 89

# --- 7. INTEGRATION ---
fix             integr all nve/sphere
# unfix           integr

# Warn if timestep > 10% of Rayleigh time or 10% of Hertz time
fix             ts_check all check/timestep/gran 1 0.1 0.1 warn no

# --- 8. ANALYSIS SETUP ---
# Get current positions of different layers
compute         z_ccc_avg ccc reduce ave z
compute         z_se_avg se reduce ave z
compute         z_acc_avg acc reduce ave z

# Print layer information
variable        z_ccc equal c_z_ccc_avg
variable        z_se equal c_z_se_avg
variable        z_acc equal c_z_acc_avg

# Count particles
variable        n_ccc equal count(ccc)
variable        n_se equal count(se)
variable        n_acc equal count(acc)

# FIXED Top and Bottom Layer from moving (Eventually would update position based on prs1)
fix 1 ccc move linear 0 0 0
fix 2 acc move linear 0 0 0

# --- 8.5. PRESSURE COMPUTATION ON CC1 ---
compute         frc1    ccc    reduce sum fz
variable        prs1    equal  -(c_frc1)*2.5e-6


# --- 9. BATTERY PHYSICS MODELS ---

# Initialize lithium content (Li/Si molar ratio) - only for AM particles
fix             li_content li property/atom/lithium_content initial 1.0 target 1.0 max 1.0

# SOR solver for electric potential with type-based boundary conditions (cathode anode) condutivity (AM, SE, CC)
fix             battery_eis_sym all battery/eis omega 1.0 tolerance 1e-1 max_iter 1000 &
                BC_types 2 3 BC_potentials 0.00 10.0 conductivity 0.05 SE_type 1

# Lithium diffusion - only for AM particles
fix             li_diffusion li lithium_diffusion Li_type 3 2 c_li_max 77101.002

# Radius expansion for Si particles (optional)
fix             radius_expand li radius_expansion Li_type 3 2 update_every 1 max_updates 100000

# --- 10. COMPUTE SETUP FOR MONITORING ---
# Electric potential by material type - NOW ELECTROLYTE POTENTIAL
compute         phi_el_se_avg se reduce ave f_electrolytePotential
compute         phi_el_ccc_avg ccc reduce ave f_electrolytePotential
compute         phi_el_acc_avg acc reduce ave f_electrolytePotential

# Electronic potential by material type
compute         phi_ed_se_avg se reduce ave f_electronicPotential
compute         phi_ed_ccc_avg ccc reduce ave f_electronicPotential
compute         phi_ed_acc_avg acc reduce ave f_electronicPotential

# Current flow at AM-SE interfaces
compute         current_avg se reduce ave f_currentSELi

variable       ts_rayleigh equal f_ts_check[1]
variable       ts_hertz    equal f_ts_check[2]
variable       ts_skin     equal f_ts_check[3]

# --- 11. OUTPUT SETTINGS ---
# Thermo output
thermo_style    custom step atoms ke c_phi_el_se_avg c_phi_ed_se_avg &
                c_phi_ed_ccc_avg c_phi_ed_acc_avg c_current_avg v_ts_rayleigh v_ts_hertz v_ts_skin v_prs1
thermo          1
thermo_modify   lost ignore norm no

# Dump for visualization
dump            dmp_battery all custom 1 1_CCD_post_bat_sym_200Mpa_exp_pack_stack/battery_*.txt id type x y z vx vy vz fx fy fz omegax omegay omegaz radius &
                f_electrolytePotential f_electronicPotential f_currentSELi f_hydrostaticStress

# --- 13. MAIN SIMULATION WITH BATTERY PHYSICS CYCLING ---
print           "================================================"
print           "Starting main battery simulation with cycling..."
print           "================================================"

# Initialize loop counter
variable        loop_count equal 0

# Main cycling loop
label           main_loop

# 1. Unfix nve/sphere
# unfix           integr

# 2. Unfix existing battery physics (if this is the first iteration)
if              "${loop_count} == 0" then &
"unfix          li_content" &
"unfix          battery_eis_sym" &
"unfix          li_diffusion" &
"unfix          radius_expand"

fix             li_content li property/atom/lithium_content initial 1.0 target 1.0 max 1.0

fix             battery_eis_sym all battery/eis omega 1.0 tolerance 1e-1 max_iter 4000 &
                BC_types 2 3 BC_potentials 0.00 10.0 conductivity 0.05 SE_type 1

fix             li_diffusion li lithium_diffusion Li_type 3 2 c_li_max 77101.002

fix             radius_expand li radius_expansion Li_type 3 2 update_every 1 max_updates 100000

# run             1

# 5. Unfix all battery physics
# unfix           li_content
# unfix           battery_eis_sym
# unfix           li_diffusion
# unfix           radius_expand

# 6. Fix nve/sphere
# fix             integr all nve/sphere

# 7. Start relax loop - maintain stack pressure at 50
# label           loop6

# Check pressure and adjust ccc movement accordingly
# if              "${prs1} > 50" then &
#                "fix 5 ccc move linear 0 0 -1000.0" &
#                elif "${prs1} < 50" &
#                "fix 5 ccc move linear 0 0 1000.0" &
#                else &
#                "fix 5 ccc move linear 0 0 0.0"

# Run for 10000 timesteps
fix 5 ccc move linear 0 0 1.0
run             120

# Check if pressure is close to target (within tolerance)
# variable        prs_diff equal abs(${prs1}-10.0)
# if              "${prs_diff} < 10.0" then "jump SELF loop7"
# jump            SELF loop6

# Hold so that kinetic energy decrease
#label           loop7
#unfix           5
#fix             5 ccc move linear 0 0 0.0

# Increment loop counter
# variable        loop_count equal ${loop_count}+1

# Check if we should continue looping
# if              "${loop_count} <= 40" then "jump SELF main_loop"

# --- 14. FINAL ANALYSIS ---
#print           "================================================"
#print           "Simulation complete after ${loop_count} cycles"
#print           "================================================"