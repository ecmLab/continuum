# Battery simulation using pre-compacted particles from restart file
# With type-based boundary conditions for SOR solver
# SE particles (type 3) - Solid Electrolyte
# AM particles (type 1) - Active Material (Si)
# CC1 particles (type 2) - Current Collector 1 (bottom) - 0V
# CC2 particles (type 6) - Current Collector 2 (top/lithium) - 0.04V

# --- 1. INITIALIZATION ---
units           micro  # Using micro units to match the compaction script
atom_style      granular
atom_modify     map array
boundary        f f f  # Fixed boundaries as in compaction script
newton          off

communicate     single vel yes

# Set timestep
timestep        5.e-6

# --- 2. READ RESTART FILE ---
# Read the compacted configuration
# read_restart    data/comp300_bat_10MPa.restart
read_data     data/comp300_bat_10MPa.data

# --- 3. RE-ESTABLISH GROUPS ---
# Define groups based on particle types from the compaction script
group  cc2   type  6   # Current Collector 2 (top/lithium) - will be 0.04V
group  se    type  3   # Solid Electrolyte
group  ghost type  5   # Ghost layer (separator) - may have been deleted
group  am    type  1   # Active Material
group  cc1   type  2   # Current Collector 1 (bottom) - will be 0V

# Groups for particles affected by walls
group  ptc   type  1 3 # Types affected by walls

# --- 4. NEIGHBOR SETTINGS ---
neighbor        0.001 bin
neigh_modify    every 1 delay 0 check yes

# --- 5. RE-ESTABLISH MATERIAL PROPERTIES ---
# Young's modulus (from compaction script)
variable        Yam           equal     48.5e6    # AM (Active Material) [kPA]
variable        Ycc           equal     50.e6   # CC1 and CC2 (Current Collectors) [kPA]
variable        Yse           equal     23.e6    # SE (Solid Electrolyte) [kPA]
variable        Yww           equal     50.e6   # Wall [kPA]
variable        Yghost        equal     50.e6   # Ghost particles [kPA]

variable        particle_poissons_ratio equal 0.4

# Material properties
fix             m1 all property/global youngsModulus peratomtype ${Yam} ${Ycc} ${Yse} ${Yww} ${Yghost} ${Ycc}
fix             m2 all property/global poissonsRatio peratomtype ${particle_poissons_ratio} ${particle_poissons_ratio} ${particle_poissons_ratio} ${particle_poissons_ratio} ${particle_poissons_ratio} ${particle_poissons_ratio}

# Coefficient of restitution (all 0.1 from compaction)
variable        cf_all equal 0.1
fix             m3 all property/global coefficientRestitution peratomtypepair 6 &
                ${cf_all} ${cf_all} ${cf_all} ${cf_all} ${cf_all} ${cf_all} &
                ${cf_all} ${cf_all} ${cf_all} ${cf_all} ${cf_all} ${cf_all} &
                ${cf_all} ${cf_all} ${cf_all} ${cf_all} ${cf_all} ${cf_all} &
                ${cf_all} ${cf_all} ${cf_all} ${cf_all} ${cf_all} ${cf_all} &
                ${cf_all} ${cf_all} ${cf_all} ${cf_all} ${cf_all} ${cf_all} &
                ${cf_all} ${cf_all} ${cf_all} ${cf_all} ${cf_all} ${cf_all}

# Coefficient of friction (all 0.1 from compaction)
variable        cof_all equal 0.1
fix             m4 all property/global coefficientFriction peratomtypepair 6 &
                ${cof_all} ${cof_all} ${cof_all} ${cof_all} ${cof_all} ${cof_all} &
                ${cof_all} ${cof_all} ${cof_all} ${cof_all} ${cof_all} ${cof_all} &
                ${cof_all} ${cof_all} ${cof_all} ${cof_all} ${cof_all} ${cof_all} &
                ${cof_all} ${cof_all} ${cof_all} ${cof_all} ${cof_all} ${cof_all} &
                ${cof_all} ${cof_all} ${cof_all} ${cof_all} ${cof_all} ${cof_all} &
                ${cof_all} ${cof_all} ${cof_all} ${cof_all} ${cof_all} ${cof_all}

# Coefficient of rolling friction (all 0.1 from compaction)
variable        corf_all equal 0.1
fix             m5 all property/global coefficientRollingFriction peratomtypepair 6 &
                ${corf_all} ${corf_all} ${corf_all} ${corf_all} ${corf_all} ${corf_all} &
                ${corf_all} ${corf_all} ${corf_all} ${corf_all} ${corf_all} ${corf_all} &
                ${corf_all} ${corf_all} ${corf_all} ${corf_all} ${corf_all} ${corf_all} &
                ${corf_all} ${corf_all} ${corf_all} ${corf_all} ${corf_all} ${corf_all} &
                ${corf_all} ${corf_all} ${corf_all} ${corf_all} ${corf_all} ${corf_all} &
                ${corf_all} ${corf_all} ${corf_all} ${corf_all} ${corf_all} ${corf_all}

# Cohesion energy density (from compaction script)
fix     m6 all property/global cohesionEnergyDensity peratomtypepair 6 &
        100000  50000  100000  0       0   50000   &
        50000   0      50000   0       0   0       &
        100000  50000  100000  0       0   50000   &
        0       0      0       0       0   0       &
        0       0      0       0       0   0       &
        50000   0      50000   0       0   0

# --- 6. PAIR STYLE AND WALLS ---
pair_style gran model hertz tangential history cohesion sjkr
pair_coeff * *

# Re-establish wall boundaries (from compaction script)
fix xwalls1 ptc wall/gran model hertz tangential history primitive type 4 xplane -10
fix xwalls2 ptc wall/gran model hertz tangential history primitive type 4 xplane 10
fix ywalls1 ptc wall/gran model hertz tangential history primitive type 4 yplane -10
fix ywalls2 ptc wall/gran model hertz tangential history primitive type 4 yplane 10
fix zwalls1 ptc wall/gran model hertz tangential history primitive type 4 zplane 0
fix zwalls2 ptc wall/gran model hertz tangential history primitive type 4 zplane 75

# --- 7. INTEGRATION ---
fix             integr all nve/sphere

# Warn if timestep > 10% of Rayleigh time or 10% of Hertz time
fix             ts_check all check/timestep/gran 1 0.1 0.1 warn yes

# --- 8. ANALYSIS SETUP ---
# Get current positions of different layers
compute         z_cc1_avg cc1 reduce ave z
compute         z_am_avg am reduce ave z
compute         z_se_avg se reduce ave z
compute         z_cc2_avg cc2 reduce ave z

# Print layer information
variable        z_cc1 equal c_z_cc1_avg
variable        z_am equal c_z_am_avg
variable        z_se equal c_z_se_avg
variable        z_cc2 equal c_z_cc2_avg

# Count particles
variable        n_cc1 equal count(cc1)
variable        n_am equal count(am)
variable        n_se equal count(se)
variable        n_cc2 equal count(cc2)
variable        n_ghost equal count(ghost)

# FIXED Top and Bottom Layer from moving
fix 1 cc1 move linear 0 0 0
fix 2 cc2 move linear 0 0 0

# --- 8.5. PRESSURE COMPUTATION ON CC1 ---
compute         frc1    cc1    reduce sum fz
variable        prs1    equal  -(c_frc1)*2.5e-6

# --- 9. BATTERY PHYSICS MODELS ---
print           "================================================"
print           "Setting up battery physics on compacted bed..."
print           "================================================"

# Check if we have AM particles
if              "${n_am} == 0" then "print 'ERROR: No AM particles found!'" quit

# Initialize battery physics fixes first to create the fix properties
# Initialize lithium content (Li/Si molar ratio) - only for AM particles
fix             li_content am property/atom/lithium_content initial 0.15 target 0.8 max 0.89

# Calculate equilibrium potential - only for AM particles
fix             eq_pot am equilibrium_potential temperature 303. U_eq0 0.35 A 20 B -15

# Calculate exchange current density - only for AM particles
fix             exch_current am exchange_current_density k_r 6e-12 c_li_max 83874. c_electrolyte 50608.

# SOR solver for electric potential with type-based boundary conditions
fix             battery_solver all battery/sor omega 0.5 tolerance 1e-5 max_iter 10000000 &
                BC_types 2 6 BC_potentials 0.04 0.00 SE_type 3 AM_type 1 temperature 303.

# Lithium diffusion - only for AM particles
fix             li_diffusion am lithium_diffusion AM_type 1 D_min 1e-15 D_poor 1e-14 D_rich 1e-13 &
                kappa 20.0 c_li_max 83874.0

# Radius expansion for Si particles (optional)
fix             radius_expand am radius_expansion AM_type 1 update_every 1 max_updates 1000000

# --- 10. COMPUTE SETUP FOR MONITORING ---
# Lithium content statistics
compute         li_avg am reduce ave f_lithiumContent
compute         li_min am reduce min f_lithiumContent
compute         li_max am reduce max f_lithiumContent

# Equilibrium potential statistics
compute         eq_avg am reduce ave f_equilibriumPotential
compute         eq_min am reduce min f_equilibriumPotential
compute         eq_max am reduce max f_equilibriumPotential

# Exchange current density statistics
compute         ex_avg am reduce ave f_exchangeCurrentDensity
compute         ex_min am reduce min f_exchangeCurrentDensity
compute         ex_max am reduce max f_exchangeCurrentDensity

# Electric potential by material type
compute         phi_se_avg se reduce ave f_electricPotential
compute         phi_am_avg am reduce ave f_electricPotential
compute         phi_cc1_avg cc1 reduce ave f_electricPotential
compute         phi_cc2_avg cc2 reduce ave f_electricPotential

# Current flow at AM-SE interfaces
compute         current_avg am reduce ave f_currentAMSE

variable       ts_rayleigh equal f_ts_check[1]
variable       ts_hertz    equal f_ts_check[2]
variable       ts_skin     equal f_ts_check[3]

# --- 11. OUTPUT SETTINGS ---
# Thermo output
thermo_style    custom step atoms ke c_li_avg c_eq_avg c_ex_avg c_phi_se_avg c_phi_am_avg &
                c_phi_cc1_avg c_phi_cc2_avg c_current_avg v_ts_rayleigh v_ts_hertz v_ts_skin v_prs1
thermo          1000
thermo_modify   lost ignore norm no

# Dump for visualization
dump            dmp_battery all custom 2000 post_bat_10Mpa/battery_*.txt id type x y z vx vy vz fx fy fz omegax omegay omegaz radius &
                f_lithiumContent f_equilibriumPotential f_exchangeCurrentDensity &
                f_electricPotential f_currentAMSE f_hydrostaticStress

# --- 13. MAIN SIMULATION WITH BATTERY PHYSICS CYCLING ---
print           "================================================"
print           "Starting main battery simulation with cycling..."
print           "================================================"

# Initialize loop counter
variable        loop_count equal 0

# Main cycling loop
label           main_loop

print           "Cycle ${loop_count}: Starting battery physics..."

# 1. Unfix nve/sphere
unfix           integr

# 2. Unfix existing battery physics (if this is the first iteration)
if              "${loop_count} == 0" then &
"unfix          li_content" &
"unfix          eq_pot" &
"unfix          exch_current" &
"unfix          battery_solver" &
"unfix          li_diffusion" &
"unfix          radius_expand"

# 3. Fix all battery physics in correct order
# Initialize lithium content (Li/Si molar ratio) - only for AM particles
fix             li_content am property/atom/lithium_content initial 0.15 target 0.8 max 0.89

# Calculate equilibrium potential - only for AM particles
fix             eq_pot am equilibrium_potential temperature 303. U_eq0 0.35 A 20 B -15

# Calculate exchange current density - only for AM particles
fix             exch_current am exchange_current_density k_r 6e-12 c_li_max 83874. c_electrolyte 50608.

# SOR solver for electric potential with type-based boundary conditions
fix             battery_solver all battery/sor omega 0.5 tolerance 1e-5 max_iter 10000000 &
                BC_types 2 6 BC_potentials 0.04 0.00 SE_type 3 AM_type 1 temperature 303.

# Lithium diffusion - only for AM particles
fix             li_diffusion am lithium_diffusion AM_type 1 D_min 1e-15 D_poor 1e-14 D_rich 1e-13 &
                kappa 20.0 c_li_max 83874.0

# Radius expansion for Si particles (optional)
fix             radius_expand am radius_expansion AM_type 1 update_every 1 max_updates 1000000

# 4. Run EC for 1 timestep, equivelent to 0.1 real seconds, while particles are frozen
run             1

# 5. Unfix all battery physics
unfix           li_content
unfix           eq_pot
unfix           exch_current
unfix           battery_solver
unfix           li_diffusion
unfix           radius_expand

# 6. Fix nve/sphere
fix             integr all nve/sphere

# 7. Start relax loop - move bottom layer downward
fix             5 cc1 move linear 0 0 -0.2

# Run fifth period: move bottom layer downward until pressure decrease maintain Stack pressure
label           loop6
run             10000
if              "${prs1} < 10" then "jump SELF loop7"
jump            SELF loop6

# Hold so that kinetic energy decrease
label           loop7
unfix           5
fix             5 cc1 move linear 0 0 0.0

# Increment loop counter
variable        loop_count equal ${loop_count}+1

# Check if we should continue looping
if              "${loop_count} <= 600" then "jump SELF main_loop"

# --- 14. FINAL ANALYSIS ---
print           "================================================"
print           "Simulation complete after ${loop_count} cycles"
print           "================================================"